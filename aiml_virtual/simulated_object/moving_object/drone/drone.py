"""
This module contains classes relating to the general drone model.
"""

import mujoco
from typing import Optional, Any, Union
import numpy as np
from abc import ABC, abstractmethod

from aiml_virtual.simulated_object.moving_object import moving_object


class Propeller:
    """
    Class that encapsulates most of the data relating to a Propeller in mujoco.

    .. todo::
        Several elements in create_xml_element in crazyflie and bumblebee may be moved here.
    """
    DIR_NEGATIVE: float = -1.0  #: **classvar** | Clockwise (left-hand) spin direction.
    DIR_POSITIVE: float = 1.0  #: **classvar** | Counter-clockwise (right-hand) spin direction.

    def __init__(self, direction: float, spin_speed: float = 0.08):
        self.ctrl: np.ndarray = np.zeros(1)  #: The allocated control input (target thrust, N) for the motor.
        self.qpos: np.ndarray = np.zeros(1)  #: Propeller joint coordinate (generalised position).
        self.angle: float = 0  #: Actual physical propeller angle.
        self.actr_force: np.ndarray = np.zeros(1)  #: The actual lift generated by the propeller.
        self.direction: float = direction  #: The direction of spin.
        self.spin_speed = spin_speed  #: The speed of the spin in the animation.

    @property
    def dir_float(self) -> float:
        """
        Property to grab the spin direction as a float for calculations.
        """
        return self.direction

    @property
    def dir_str(self) -> str:
        """
        Property to grab the spin direction as a string for XML creation.
        """
        return "" if self.direction > 0 else "-"

    @property
    def dir_mesh(self) -> str:
        """
        Property to grab the spin direction in terms of cw/ccw for XML creation.
        """
        return "ccw" if self.direction > 0 else "cw"

    def spin(self) -> None:
        """
        Spins the propellers in the mujoco display (but has no physical effect).

        .. note::
            Here used to be a code segment that spun the propeller proportionally to the actuator output, but personally
            I think it looked a bit weird.

            .. code-block:: python

                self.angle += self.dir_float * self.ctrl[0] * self.spin_speed
                self.qpos[0] = self.angle

            I think it looks more natural if the propellers simply spin at an even rate, when looked at via the naked
            eye we can't tell whether the spin rate is proportional to the thrust anyway.
        """
        self.angle += self.spin_speed
        self.qpos[0] = self.angle

class Drone(moving_object.MovingObject):
    """
    Class encapsulating behaviour common to all drones (which are MovingObjects).
    """
    def __init__(self):
        super().__init__()
        self.sensors: dict[str, np.array] = {}  #: Dictionary of sensor data.
        self.propellers: list[Propeller] = [Propeller(Propeller.DIR_POSITIVE), Propeller(Propeller.DIR_NEGATIVE),
                                            Propeller(Propeller.DIR_POSITIVE), Propeller(Propeller.DIR_NEGATIVE)] #: List of propellers; first and third are ccw, second and fourth are cw
        self.state: dict[str, np.ndarray] = self.sensors  #: Convenience alias for sensors.
        self.ctrl_output: np.ndarray = np.zeros(4)  #: Output of the controllers, usually force-torque(x3).

    @property
    @abstractmethod
    def input_matrix(self) -> np.ndarray:
        """
        Property to grab the input matrix for use in input allocation: it shows the connection between the control
        outputs (thrust-toruqeX-torqueY-torqueZ) and the individual motor thrusts.
        """
        pass

    @property
    def mass(self) -> Union[None, float, np.array]:
        """
        Property to look up the mass of the drone in the mjModel.
        """
        if self.model:
            return self.model.body(self.name).mass
        else:
            return None

    @property
    def inertia(self) -> Union[None, np.ndarray]:
        """
        Property to look up the diagonal inertia of the drone in the mjModel.
        """
        if self.model:
            return self.model.body(self.name).inertia
        else:
            return None

    @classmethod
    def get_identifiers(cls) -> Optional[list[str]]:
        """
        Overrides method in MovingObject to specify whether to check for aliases when parsing an XML.

        Returns:
            Optional[list[str]]: The list of aliases for objects belonging to this class.
        """
        return ["Drone", "drone"]

    @abstractmethod
    def set_default_controller(self) -> None:
        """
        For ease, all drone types may have a default controller type. This method instantiates it, and sets it for use.
        """
        pass

    def spin_propellers(self) -> None:
        """
        Updates the display of the propellers, to make it look like they are spinning.
        """
        if self.sensors["pos"][2] > 0.015:  # only start spinning if the drone has taken flight
            for propeller in self.propellers:
                propeller.spin()

    def update(self, mj_step_count: int, step: float) -> None:
        """
        Overwrites SimulatedObject.update. Updates the position of the propellers to make it look like they are
        spinning, and runs the controller.
        Args:
            mj_step_count (int): The **physics** step count.
            step (float): The length (in seconds, when using SI base units) of a **physics** step.
        """
        # todo: check this as compared to the original when cleaning up
        self.spin_propellers()  # update how the propellers look
        if self.trajectory:  # if we don't have a trajectory, we don't have a reference for the controller: skip
            setpoint = self.trajectory.evaluate(self.data.time)
            self.ctrl_output = self.controller.compute_control(state=self.state, setpoint=setpoint)
            motor_thrusts = self.input_matrix @ self.ctrl_output
            for propeller, thrust in zip(self.propellers, motor_thrusts):
                propeller.ctrl[0] = thrust

    def bind_to_data(self, data: mujoco.MjData) -> None:
        """
        Overwrites SimulatedObstacle.bind_to_data. Saves the references of the sensors and propellers from the data.
        Also sets a default controller if one has not been set yet.

        Args:
             data (mujoco.MjData): The data of the simulation (as opposed to the *model*).
        """
        if self.model is None:
            raise RuntimeError
        if self.controller is None:
            self.set_default_controller()
        self.data = data
        self.sensors["ang_vel"] = self.data.sensor(self.name + "_gyro").data
        self.sensors["vel"] = self.data.sensor(self.name + "_velocimeter").data
        self.sensors["acc"] = self.data.sensor(self.name + "_accelerometer").data
        self.sensors["pos"] = self.data.sensor(self.name + "_posimeter").data
        self.sensors["quat"] = self.data.sensor(self.name + "_orimeter").data
        self.sensors["ang_acc"] = self.data.sensor(self.name + "_ang_accelerometer").data
        for i, propeller in enumerate(self.propellers):
            prop_joint = self.data.joint(f"{self.name}_prop{i}")
            propeller.qpos = prop_joint.qpos
            propeller.angle = propeller.qpos[0]
            propeller.ctrl = self.data.actuator(f"{self.name}_actr{i}").ctrl
            propeller.actr_force = self.data.actuator(f"{self.name}_actr{i}").force





