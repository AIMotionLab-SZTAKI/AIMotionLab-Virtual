jelenleg a flow:
-valami modelből inicializáljuk a scene-t (a scene a model-hez tartozik, tulajdonképpen egyszerre van benne a model és a Python objektumok)
	ennek a parseolás is része, ami létrehozza a megfelelő simulated objecteket, melyeket bind-ol a konstruktor
-a felhasználó megcsinálja az objektjeit, és addolja
-addolás: minden objektum a saját belátása szerint csinál egy XML dict-et, amit berakunk az etree-be (Etree reprezentáció friss)
	  hozzáadjuk a simulated object-eknek a listájához (simulatedobject friss)
	  újratöltjük a modellt: kiírjuk fájlba és a modellt is újratöltjük (mujoco model frissült, xml frissült)


ehhez passive viewer fog kelleni: viewer.launch_passive(model, data)
lock(): fizikával kapcsolatos dolgokhoz szemafor
sync(): előző sync óta történt változásokkal aktualizálza a mjModel-t és mjData-t (?) Nem feltétlen értem hogyan viszonyul a lock-hoz
close(): bezárja a viewert, ha viewer handle-t használunk mint context manager, akkor nem szükséges
user_scn: egy olyan mjvScene (az mjvScene minden openGL-el kapcsolatos dolgot kezel), amin keresztül állíthatók a rendereléshez
kapcsolüdü dolgok? Elvileg ebben lehetne hozzáadni custom geom-okat (TODO :D). A kövi sync() hívás behozza a változásokat
----------------------------------------------------------------------------------------------------------------------------------------------

a launch_passive() egy handle-t ad vissza
lehet neki adni show_left_ui és show_right_ui parancsokat, valamint (és ez a legfontosabb), egy Optional KeyCallbackType-t
a key_callback egy olyan függvény, ami meghívódik minden alkalommal amikor egy keyboard event történik a viewer ablakban
ennek a függvénynek a switch/case-je fogja eldönteni mit kell csinálni
----------------------------------------------------------------------------------------------------------------------------------------------
végig kell gondolni hogyan fog működni a controller:
a szimulátor meghívja minden object-nek a saját update-jét
az object update-je:
self.ctrl[0] = self.controller.compute_control(i)
self.ctrl = self.actr.ctrl
ez tulajdonképpen a Data-hoz bindolás, ami majd a simulator feladata lesz
az egyes update-ek argumentumai: i, control step
----------------------------------------------------------------------------------------------------------------------------------------------
Tisztázni kell majd:
Drone egésze
crazyflie és bumblebee leválasztása a Drone-ról
Trajectory
setpoint, stb (saját class? beágyazott class tetszene, mert egy adott setpoint típus egy adott controllerhez tud tartozni, hacsak nem 
teszünk bele mindent a setpointba, és a bizonyos controllerek mindig csak egy részét használják). Ezzel kapcsolódóan azt is meg kéne
reformálni, hogy ne dict-ben legyenek a cuccok, mert egy rakás KeyError-hoz vezet
ugyanezeknél a típusokat is végig kéne venni
update_controller_type-t is meg kellhet majd csinálni, ezt meg kell nézni a wikiből
*****************************************************
szépen sorban:
-mappába rendezni szépen
-szétszedni a crazyfliet és a bumblebee-t
	-majdnem megvan, szét van szedve de még bele kell rakni a bumblebee-t
-type hint-eket rendesen megcsinálni, és kommentezni (lesz rá még second pass a docstring írásnál)
-egységesíteni minden movingobject-hez tartozó dolgot: trajectory, controller, stb
-megcsinálni a sphinx dolgokat
----------------------------------------------------------------------------------------------------------------------------------------------
sphinx:




























































